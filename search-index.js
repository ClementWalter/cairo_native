var searchIndex = JSON.parse('{\
"sierra2mlir":{"doc":"A compiler to convert Cairo’s intermediate …","t":[3,11,11,11,11,11,11,0,11,11,11,11,11,12,11,0,5,12,0,11,11,11,0,11,11,11,3,3,11,11,11,11,11,12,11,12,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,12,11,11],"n":["Args","augment_args","augment_args_for_update","borrow","borrow_mut","command","command_for_update","compiler","fmt","from","from_arg_matches","from_arg_matches_mut","group_id","input","into","libfuncs","main","output","statements","try_from","try_into","type_id","types","upcast","update_from_arg_matches","update_from_arg_matches_mut","Compiler","Storage","bool_type","borrow","borrow","borrow_mut","borrow_mut","code","compile","context","default","felt_add_create","felt_sub_create","felt_type","fmt","from","from","i32_type","into","into","module","named_attribute","new","new_block","op_const","op_eq","op_felt_add","op_felt_const","op_felt_mul","op_felt_rem","op_felt_sub","op_func","op_func_call","op_return","process_libfuncs","process_statements","process_types","program","run_fib","try_from","try_from","try_into","try_into","type_id","type_id","types","upcast","upcast"],"q":["sierra2mlir","","","","","","","","","","","","","","","","","","","","","","","","","","sierra2mlir::compiler","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["","","","","","","","","","Returns the argument unchanged.","","","","The input sierra file.","Calls <code>U::from(self)</code>.","","","The output file.","","","","","","","","","","Types, functions, etc storage. This aproach works better …","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","Creates a new block","New constant","Only the MLIR op.","Only the MLIR op, doesn’t do modulo.","New felt constant","Only the MLIR op.","Only the MLIR op.","Only the MLIR op, doesn’t do modulo.","Example function_type: “(i64, i64) -&gt; i64”","","","","","","","","","","","","","","","",""],"i":[0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,2,0,2,2,2,0,2,2,2,0,0,12,12,15,12,15,12,12,12,15,12,12,12,15,12,15,12,12,15,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,15,12,15,12,15,15,12,15],"f":[0,[1,1],[1,1],[[]],[[]],[[],1],[[],1],0,[[2,3],4],[[]],[5,[[7,[2,6]]]],[5,[[7,[2,6]]]],[[],[[9,[8]]]],0,[[]],0,[[],10],0,0,[[],7],[[],7],[[],11],0,[[]],[[2,5],[[7,[6]]]],[[2,5],[[7,[6]]]],0,0,[12,13],[[]],[[]],[[]],[[]],0,[12,[[10,[14]]]],0,[[],15],[12,[[10,[16]]]],[12,[[10,[16]]]],[12,13],[[15,3],4],[[]],[[]],[12,13],[[]],[[]],0,[[12,17,17]],[17,[[10,[12]]]],[12,18],[[12,18,17,13],14],[[12,18,19,19],14],[[12,18,19,19],14],[[12,18,17],14],[[12,18,19,19],14],[[12,18,19,19],14],[[12,18,19,19],14],[[12,17,17,[21,[20]]],16],[[12,18,17],14],[[12,18],14],[[12,15],10],[[12,15],10],[[12,15]],0,[12,[[10,[14]]]],[[],7],[[],7],[[],7],[[],7],[[],11],[[],11],0,[[]],[[]]],"p":[[3,"Command"],[3,"Args"],[3,"Formatter"],[6,"Result"],[3,"ArgMatches"],[6,"Error"],[4,"Result"],[3,"Id"],[4,"Option"],[6,"Result"],[3,"TypeId"],[3,"Compiler"],[3,"Type"],[3,"OperationRef"],[3,"Storage"],[3,"Operation"],[15,"str"],[3,"Block"],[3,"Value"],[3,"Region"],[3,"Vec"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
