var searchIndex = JSON.parse('{\
"cli":{"doc":"A compiler to convert Cairo’s intermediate …","t":[3,4,13,13,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,12,11,11,5,12,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12],"n":["Args","Commands","Compile","Run","augment_args","augment_args_for_update","augment_subcommands","augment_subcommands_for_update","borrow","borrow","borrow_mut","borrow_mut","command","command","command_for_update","from","from","from_arg_matches","from_arg_matches","from_arg_matches_mut","from_arg_matches_mut","group_id","has_subcommand","input","into","into","main","optimize","try_from","try_from","try_into","try_into","type_id","type_id","upcast","upcast","update_from_arg_matches","update_from_arg_matches","update_from_arg_matches_mut","update_from_arg_matches_mut","debug","function","output"],"q":["cli","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","cli::Commands","",""],"d":["","","Compile to MLIR with LLVM dialect, ready to be converted …","Compile and run a program. The entry point must be a …","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","The input sierra file.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","Output optimized MLIR.","","","","","","","","","","","","","Turn on debug info.","The function to run. Can only run functions without …","The output file. If not specified its output will be …"],"i":[0,0,6,6,3,3,6,6,3,6,3,6,3,3,3,3,6,3,6,3,6,3,6,3,3,6,0,3,3,6,3,6,3,6,3,6,3,6,3,6,13,14,13],"f":[0,0,0,0,[1,1],[1,1],[1,1],[1,1],[[]],[[]],[[]],[[]],[[],1],0,[[],1],[[]],[[]],[2,[[5,[3,4]]]],[2,[[5,[6,4]]]],[2,[[5,[3,4]]]],[2,[[5,[6,4]]]],[[],[[8,[7]]]],[9,10],0,[[]],[[]],[[],11],0,[[],5],[[],5],[[],5],[[],5],[[],12],[[],12],[[]],[[]],[[3,2],[[5,[4]]]],[[6,2],[[5,[4]]]],[[3,2],[[5,[4]]]],[[6,2],[[5,[4]]]],0,0,0],"p":[[3,"Command"],[3,"ArgMatches"],[3,"Args"],[6,"Error"],[4,"Result"],[4,"Commands"],[3,"Id"],[4,"Option"],[15,"str"],[15,"bool"],[6,"Result"],[3,"TypeId"],[13,"Compile"],[13,"Run"]]},\
"sierra2mlir":{"doc":"A compiler to convert Cairo’s intermediate …","t":[5,0,5,3,3,4,13,3,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12],"n":["compile","compiler","execute","Compiler","FunctionDef","SierraType","Simple","Storage","Struct","bool_type","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","code","compile","context","create_fn_signature","create_libfunc_dup","create_libfunc_felt_add","create_libfunc_felt_const","create_libfunc_felt_mul","create_libfunc_felt_sub","create_libfunc_store_temp","create_libfunc_struct_construct","default","double_felt_type","felt_type","fmt","fmt","fmt","from","from","from","from","i32_type","into","into","into","into","module","named_attribute","new","new_block","op_add","op_const","op_eq","op_felt_const","op_felt_modulo","op_func","op_func_call","op_llvm_extractvalue","op_llvm_insertvalue","op_llvm_struct","op_mul","op_rem","op_return","op_sext","op_sub","op_trunc","op_zext","prime_constant","process_libfuncs","process_statements","process_types","program","run_fib","run_gpu","struct_type_string","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","upcast","upcast","upcast","upcast","field_types","ty"],"q":["sierra2mlir","","","sierra2mlir::compiler","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","sierra2mlir::compiler::SierraType",""],"d":["","","","","","","","Types, functions, etc storage. This aproach works better …","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the given value, needed so its handled nicely when …","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","Creates a new block","Only the MLIR op, doesn’t do modulo.","New constant","Only the MLIR op.","New felt constant","Does modulo prime and truncates back to felt type.","Example function_type: “(i64, i64) -&gt; i64”","","extracts a value from the specified struct.","inserts a value into the specified struct.","creates a llvm struct","Only the MLIR op.","Only the MLIR op.","","","Only the MLIR op, doesn’t do modulo.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,9,0,9,7,7,9,10,11,7,9,10,11,9,10,11,9,10,11,7,7,7,7,7,7,7,7,7,7,7,11,7,7,9,10,11,7,9,10,11,7,7,9,10,11,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,9,10,11,7,9,10,11,7,9,10,11,7,9,10,11,7,9,10,11,28,28],"f":[[[1,2,2],[[5,[3,4]]]],0,[1,[[5,[6,4]]]],0,0,0,0,0,0,[7,8],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[9,9],[10,10],[11,11],[[]],[[]],[[]],0,[7,[[13,[12]]]],0,[7,3],[[7,14,15,[17,[[16,[11]]]]],13],[[7,14,15,[17,[[16,[11]]]]],13],[[7,14,11]],[[7,14,15,[17,[[16,[11]]]]],13],[[7,14,15,[17,[[16,[11]]]]],13],[[7,14,15,[17,[[16,[11]]]]],13],[[7,14,15,[17,[[16,[11]]]]],13],[[],11],[7,8],[7,8],[[9,18],19],[[10,18],19],[[11,18],19],[[]],[[]],[[]],[[]],[7,8],[[]],[[]],[[]],[[]],0,[[7,1,1],[[13,[20]]]],[1,[[13,[7]]]],[7,21],[[7,21,22,22],12],[[7,21,1,8],12],[[7,21,22,22],12],[[7,21,1],12],[[7,21,22],[[13,[12]]]],[[7,1,1,[24,[23]],2],[[13,[25]]]],[[7,21,1],[[13,[12]]]],[[7,21,26,22,8],[[13,[12]]]],[[7,21,26,22,22,1],[[13,[12]]]],[[7,21],12],[[7,21,22,22],12],[[7,21,22,22],12],[[7,21],12],[[7,21,22,8],12],[[7,21,22,22],12],[[7,21,22,8],12],[[7,21,22,8],12],[[7,21],12],[[7,[17,[[16,[11]]]]],13],[[7,[17,[[16,[11]]]]],13],[[7,[17,[[16,[11]]]]],13],0,[7,[[13,[12]]]],[7,[[13,[12]]]],[7,3],[[]],[[]],[[]],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],5],[[],27],[[],27],[[],27],[[],27],[[]],[[]],[[]],[[]],0,0],"p":[[15,"str"],[15,"bool"],[3,"String"],[3,"Report"],[4,"Result"],[3,"ExecutionEngine"],[3,"Compiler"],[3,"Type"],[4,"SierraType"],[3,"FunctionDef"],[3,"Storage"],[3,"OperationRef"],[6,"Result"],[3,"LibfuncDeclaration"],[3,"BlockRef"],[3,"RefCell"],[3,"Rc"],[3,"Formatter"],[6,"Result"],[3,"NamedAttribute"],[3,"Block"],[3,"Value"],[3,"Region"],[3,"Vec"],[3,"Operation"],[15,"usize"],[3,"TypeId"],[13,"Struct"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
